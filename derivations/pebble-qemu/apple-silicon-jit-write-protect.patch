Mostly adapted from https://gitlab.com/qemu-project/qemu/-/commit/653b87eb36045b506b79f0bb433016ef1c54bc9a.

diff --git a/cpu-exec.c b/cpu-exec.c
index c88d0ffdc..4fc5bcc51 100644
--- a/cpu-exec.c
+++ b/cpu-exec.c
@@ -154,6 +154,7 @@ static inline tcg_target_ulong cpu_tb_exec(CPUState *cpu, uint8_t *tb_ptr)
 #endif /* DEBUG_DISAS */
 
     cpu->can_do_io = !use_icount;
+    qemu_thread_jit_execute();
     next_tb = tcg_qemu_tb_exec(env, tb_ptr);
     cpu->can_do_io = 1;
     trace_exec_tb_exit((void *) (next_tb & ~TB_EXIT_MASK),
diff --git a/include/exec/exec-all.h b/include/exec/exec-all.h
index d900b0d07..2ebe7862c 100644
--- a/include/exec/exec-all.h
+++ b/include/exec/exec-all.h
@@ -324,6 +324,7 @@ static inline void tb_add_jump(TranslationBlock *tb, int n,
 {
     /* NOTE: this test is only needed for thread safety */
     if (!tb->jmp_next[n]) {
+        qemu_thread_jit_write();
         /* patch the native jump address */
         tb_set_jmp_target(tb, n, (uintptr_t)tb_next->tc_ptr);
 
diff --git a/include/qemu/osdep.h b/include/qemu/osdep.h
index 84e84ac70..187de3553 100644
--- a/include/qemu/osdep.h
+++ b/include/qemu/osdep.h
@@ -69,6 +69,10 @@
 #include "sysemu/os-posix.h"
 #endif
 
+#ifdef CONFIG_DARWIN
+#include <AvailabilityMacros.h>
+#endif
+
 #include "qapi/error.h"
 
 #if defined(CONFIG_SOLARIS) && CONFIG_SOLARIS_VERSION < 10
@@ -315,4 +319,7 @@ int qemu_read_password(char *buf, int buf_size);
  */
 pid_t qemu_fork(Error **errp);
 
+static inline void qemu_thread_jit_execute(void);
+static inline void qemu_thread_jit_write(void);
+
 #endif
diff --git a/tcg/tcg.c b/tcg/tcg.c
index a163541d3..880e8d058 100644
--- a/tcg/tcg.c
+++ b/tcg/tcg.c
@@ -373,6 +373,7 @@ void tcg_prologue_init(TCGContext *s)
     s->code_gen_prologue = buf0;
 
     /* Generate the prologue.  */
+    qemu_thread_jit_write();
     tcg_target_qemu_prologue(s);
     buf1 = s->code_ptr;
     flush_icache_range((uintptr_t)buf0, (uintptr_t)buf1);
diff --git a/translate-all.c b/translate-all.c
index 042a8576a..7ae7efcef 100644
--- a/translate-all.c
+++ b/translate-all.c
@@ -672,6 +672,13 @@ static inline void *alloc_code_gen_buffer(void)
 #  endif
 # endif
 
+#if defined(CONFIG_DARWIN) && defined(__aarch64__)
+    // A change to mprotect in macOS 11.2 on Apple Silicon prevents the call from working on
+    // regions without the MAP_JIT flag. There's also some manual switching required between
+    // RW and RX perms needed - see calls to qemu_thread_jit_(write|execute).
+    flags |= MAP_JIT;
+#endif
+
     buf = mmap((void *)start, size + qemu_real_host_page_size,
                PROT_NONE, flags, -1, 0);
     if (buf == MAP_FAILED) {
@@ -975,6 +982,8 @@ void tb_phys_invalidate(TranslationBlock *tb, tb_page_addr_t page_addr)
     tb_page_addr_t phys_pc;
     TranslationBlock *tb1, *tb2;
 
+    qemu_thread_jit_write();
+
     /* remove the TB from the hash list */
     phys_pc = tb->page_addr[0] + (tb->pc & ~TARGET_PAGE_MASK);
     h = tb_phys_hash_func(phys_pc);
@@ -1022,6 +1031,8 @@ void tb_phys_invalidate(TranslationBlock *tb, tb_page_addr_t page_addr)
     tb->jmp_first = (TranslationBlock *)((uintptr_t)tb | 2); /* fail safe */
 
     tcg_ctx.tb_ctx.tb_phys_invalidate_count++;
+
+    qemu_thread_jit_execute();
 }
 
 static void build_page_bitmap(PageDesc *p)
@@ -1068,6 +1079,8 @@ TranslationBlock *tb_gen_code(CPUState *cpu,
     int64_t ti;
 #endif
 
+    qemu_thread_jit_write();
+
     phys_pc = get_page_addr_code(env, pc);
     if (use_icount && !(cflags & CF_IGNORE_ICOUNT)) {
         cflags |= CF_USE_ICOUNT;
diff --git a/util/osdep.c b/util/osdep.c
index 534b51147..8bc27795f 100644
--- a/util/osdep.c
+++ b/util/osdep.c
@@ -435,3 +435,21 @@ writev(int fd, const struct iovec *iov, int iov_cnt)
     return readv_writev(fd, iov, iov_cnt, true);
 }
 #endif
+
+#if defined(CONFIG_DARWIN) && defined(__aarch64__)
+static inline void qemu_thread_jit_execute(void)
+{
+    if (__builtin_available(macOS 11.0, *)) {
+        pthread_jit_write_protect_np(true);
+    }
+}
+static inline void qemu_thread_jit_write(void)
+{
+    if (__builtin_available(macOS 11.0, *)) {
+        pthread_jit_write_protect_np(false);
+    }
+}
+#else
+static inline void qemu_thread_jit_execute() {}
+static inline void qemu_thread_jit_write() {}
+#endif
